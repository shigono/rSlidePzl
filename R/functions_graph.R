plotGraph <- function(
  g,
  status_color = c("blue", "skyblue", "gray", "red"),
  status_label = FALSE,
  move_label   = TRUE,
  method       = 'igraph',
  ...
){
  #' plot a network graph
  #'
  #' provide an easy way to plot a network graph returned by \code{makeGraph} function.
  #'
  #' To plot with more detailed
  #' specification, use \code{igraph::tkplot} or
  #' \code{GGally::ggnet2} function instead.
  #' For huge graphs consider to use other software like Gephi.
  #'
  #' see \code{\link{makeGraph}} for example code.
  #'
  #' @export
  #' @param g an object generated by \code{makeGraph} function.
  #' @param status_color a vector of color, length 4.
  #'                     Color of (initial, unexamined,
  #'                     examined, goal) states
  #' @param status_label logical. show labels of states?
  #' @param move_label logical. show labels of transition?
  #' @param method 'igraph': use \code{igraph::plot}; 'GGally': use \code{GGally::ggnet2}
  #' @param ... pass to \code{igraph::plot} or \code{GGally::ggnet2}
  #' @importFrom igraph E
  #' @importFrom igraph V
  #' @importFrom igraph plot.igraph
  #' @importFrom GGally ggnet2

  stopifnot(method %in% c('igraph', "GGally"))

  if (method == 'igraph'){

    if (status_label){
      vlabel = V(g)$name
    } else {
      vlabel = NA
    }

    if (move_label){
      elabel = E(g)$name
    } else {
      elabel = NA
    }

    plot.igraph(
      g,
      vertex.size        = 8,
      vertex.color       = status_color[V(g)$status],
      vertex.frame.color = NA,
      vertex.label       = vlabel,
      vertex.label.size  = 1,
      edge.arrow.size    = 0.2,
      edge.arrow.width   = 0.2,
      edge.label         = elabel,
      edge.label.family  = 'sans',
      edge.label.cex     = 1,
      edge.label.color   = "black",
      ...
    )
  }

  if (method == 'GGally'){

    if (status_label){
      vlabel = V(g)$name
    } else {
      vlabel = FALSE
    }

    if (move_label){
      elabel = E(g)$name
    } else {
      elabel = FALSE
    }

    ggnet2(
      g,
      size            = 6,
      node.alpha      = 0.5,
      label           = vlabel,
      edge.label      = elabel,
      edge.label.size = 4,
      arrow.size      = 6,
      arrow.gap       = 0.025,
      arrow.type      = "closed",
      color           = status_color[V(g)$status]
    )
  }
}
getAllShortestPaths <- function(g, target = NULL){
  #' get all of shortest paths to target
  #'
  #' Get all of shortest paths from initial states to goal states
  #' (or to specified states). It may take a long time.
  #'
  #' see \code{\link{makeGraph}} for example code.
  #'
  #' @export
  #' @param g an 'igraph' object generated by \code{makeGraph} function.
  #' @param target a numerical vector, which gives
  #'               IDs of target states. NULL means IDs of goal states.
  #' @importFrom igraph all_shortest_paths
  #' @importFrom igraph E
  #' @importFrom igraph is.igraph
  #' @return a list with following elements:
  #'         \describe{
  #'           \item{state}{a list of character vectors.
  #'           ith element gives states in the ith path.}
  #'           \item{transition}{a list of character vectors.
  #'           ith element gives transitions in the ith path.}
  #'         }
  #'

  stopifnot(is.igraph(g))

  if (is.null(target)){
    target <- seq_along(V(g))[V(g)$status == 4]
  }
  stopifnot(length(target) > 0)
  stopifnot(target %in% seq_along(V(g)))

  anDepth <- as.integer(V(g)$depth)
  anTarget <- target[anDepth == min(anDepth)]

  lPath <- all_shortest_paths(g, from = 1, to = anTarget, mode = "all")

  lState <- lapply(
    lPath$res,
    function(x) x$name
  )

  lMove <- lapply(
    lPath$res,
    function(nodes){
      anStateID <- as.integer(nodes)
      mnStateID <- matrix(NA, nrow = length(anStateID) - 1, 2)
      mnStateID[,1] <- anStateID[-length(anStateID)]
      mnStateID[,2] <- anStateID[-1]
      E(g, P = unlist(t(mnStateID)))$name
    }
  )

  list(state = lState, transition = lMove)
}
getShortestPath <- function(g, target = NULL){
  #' get a shortest paths to target
  #'
  #' get one of the shortest path from initial states to goal states
  #' (or to specified states).
  #'
  #' @export
  #' @param g an 'igraph' object generated by \code{makeGraph} function.
  #' @param target a numerical vector, which gives
  #'               IDs of target states. NULL means IDs of goal states.
  #' @importFrom igraph shortest_paths
  #' @importFrom igraph E
  #' @return a list with following elements:
  #'         \describe{
  #'           \item{state}{a character vector, giving states of the path.}
  #'           \item{transition}{a character vectors,
  #'           giving transitions of the path.}
  #'         }
  #'

  stopifnot(is.igraph(g))

  if (is.null(target)){
    target <- seq_along(V(g))[V(g)$status == 4]
  }
  stopifnot(length(target) > 0)
  stopifnot(target %in% seq_along(V(g)))

  anDepth <- as.integer(V(g)$depth)
  anTarget <- target[anDepth == min(anDepth)]

  lPath <- shortest_paths(g, from = 1, to = anTarget[1], output = "vpath")

  anStateID <- as.integer(lPath$vpath[[1]])
  mnStateID <- matrix(NA, nrow = length(anStateID) - 1, 2)
  mnStateID[,1] <- anStateID[-length(anStateID)]
  mnStateID[,2] <- anStateID[-1]
  asMove <- E(g, P = unlist(t(mnStateID)))$name

  list(state = lPath$vpath[[1]], transition = asMove)
}
getReachability <- function(g, target = NULL){
  #' get reachability to goal states
  #'
  #' get reachability to goal states (or to `target` states if specified).
  #' See details.
  #'
  #' Reachability of a state represent
  #' whether it is on any acyclic path to any of goal states
  #' (or to any of `target` states if specified).
  #'
  #' Suppose you proceeded from the initial state of the sliding puzzles.
  #' \itemize{
  #' \item
  #' When your current state is "reachable", you are on the right track.
  #' By proceeding further from there, you can
  #' achive one of goal (or `target``) states
  #' without returning states which you have already passes through
  #' (and without being interrupted by any of goal states,
  #' if `target` is specified).
  #' \item
  #' When your current state is "unreachable", something goes wrong.
  #' By proceeding further from there you will eventually see
  #' states which you have already passes through
  #' (or will be intrrupted by any of goal states if `target` is specified) before
  #' you achive one of goal (`target`) states.
  #' }
  #'
  #' "Reachability" of a state is a wider concept than
  #' whether it is on the shortest pathes to the goal (target) states:
  #' States on the longer pathes are also "reachable".
  #'
  #' @export
  #' @param g an 'igraph' object generated by \code{makeGraph} function.
  #' @param target a numerical vector, which gives
  #'               IDs of target states. NULL means IDs of goal states.
  #' @importFrom igraph is.igraph
  #' @importFrom igraph E
  #' @importFrom igraph V
  #' @importFrom igraph as_edgelist
  #' @return a binary vector of the length of the number of states in `g`.
  #'         The ith element gives reachability of the ith state in `g`
  #'         (0:unreachable, 1:reachable)

  # trap: g
  stopifnot(is.igraph(g))

  # defing target
  if (is.null(target)){
    target <- seq_along(V(g))[V(g)$status == 4]
  }
  # trap: target
  stopifnot(length(target) > 0)
  stopifnot(target %in% seq_along(V(g)))

  # 各ノードの深さ
  anDepth <- as.integer(V(g)$depth)
  # エッジ行列
  mnEdge <- as_edgelist(g, names = FALSE)

  # 一番深い階層から順に上がっていくループ。
  # lapplyで書くほうが一見スマートではあるが、「それよりひとつ深い
  # 階層でどのノードが到達可能だったか」を調べなければならず、
  # そのためにはlapplyのなかでコールする関数の実行環境の外側を
  # 観に行かないといけないわけで、結局わかりにくい。
  # ここではforループでなんとかする

  # ノード番号。単に連番
  anStateID <- seq_along(anDepth)
  # 各ノードがゴールに到達可能かどうか。このベクトルを更新する
  out <- rep(NA, length(anDepth))

  for (nCurrentDepth in seq(max(anDepth), 0)){

    # これから調べる深さ
    # cat("nCurrentDepth:", nCurrentDepth, "\n")

    # これから調べるノード番号のベクトル
    anCurrentID <- anStateID[anDepth == nCurrentDepth]
    ## cat("anCurrentID:", anCurrentID, "\n")

    # それより一段深いノード番号のベクトル. 1回目のループでは空
    anNextDepthID <- anStateID[anDepth == nCurrentDepth+1]
    ## cat("anNextDepthID:", anNextDepthID, "\n")

    # それより一段深いノード番号のうちゴールに到達可能な番号のベクトル。1回目のループでは空
    anNextDepthHitID <- anNextDepthID[!is.na(out[anNextDepthID]) & out[anNextDepthID] == 1]
    ## cat("anNextDepthHitID:", anNextDepthHitID, "\n")

    # anNextDepthHitIDへのエッジを持つか、それ自身がゴールであるノードを探して
    anCandidate <- unique(c(mnEdge[mnEdge[,2] %in% anNextDepthHitID, 1], target))

    # 書き込む
    stopifnot(is.na(out[anCurrentID]))
    out[anCurrentID] <- ifelse(anCurrentID %in% anCandidate, 1, 0)
  }
  stopifnot(!is.na(out))

  return(out)
}
